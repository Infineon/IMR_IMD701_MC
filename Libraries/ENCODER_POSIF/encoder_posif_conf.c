/*********************************************************************************************************************
* DAVE APP Name : ENCODER_POSIF       APP Version: 4.0.6
*
* NOTE:
* This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
*********************************************************************************************************************/

/**
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-07-06:
 *     - Initial version
 *
 * 2019-11-26:
 *     - CCU4 inputs adaptations for XMC14
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "encoder_posif.h"
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/

XMC_GPIO_CONFIG_t ENCODER_POSIF_0_Encoder_PadConfig  =
{
  .mode            = (XMC_GPIO_MODE_t)XMC_GPIO_MODE_INPUT_TRISTATE,
  .output_level    = (XMC_GPIO_OUTPUT_LEVEL_t)XMC_GPIO_OUTPUT_LEVEL_LOW,
  
  .input_hysteresis= 0
  
};

ENCODER_POSIF_GPIO_t ENCODER_POSIF_0_Index_PadResource =
{
  .port = XMC_GPIO_PORT4,
  .pin  = 3U
};

ENCODER_POSIF_GPIO_t ENCODER_POSIF_0_Phase_A_PadResource =
{
  .port = XMC_GPIO_PORT4,
  .pin  = 2U
};
ENCODER_POSIF_GPIO_t ENCODER_POSIF_0_Phase_B_PadResource =
{
  .port = XMC_GPIO_PORT4,
  .pin  = 1U
};

/**************************************************************************************************************/
/***************************************Encoder Enable Pin Configuration***************************************/
/**************************************************************************************************************/
ENCODER_POSIF_GPIO_t ENCODER_POSIF_0_Enable_Encoder_PadResource =
{
  .port = XMC_GPIO_PORT4,
  .pin  = 10U
};

/* GPIO Init handle for Inverter enable Pin */
XMC_GPIO_CONFIG_t ENCODER_POSIF_0_En_Encoderpin_Config = 
{
 .mode             = XMC_GPIO_MODE_OUTPUT_PUSH_PULL,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_HIGH,
 .input_hysteresis = (XMC_GPIO_INPUT_HYSTERESIS_t)0,
};

MOTOR_LIB_PT1Handle_t ENCODER_POSIF_0_Speed_PT1Filter =
{
  .z1      = (int32_t)163,
  .y_max   = (int32_t)0x7FFFFFFF,
  .y_min   = (int32_t)0x80000001,
  .pt1_buf = (int32_t)0
};

/**************************************************************************************************************/
/*************************************CC4 Event Configuration Configuration************************************/
/**************************************************************************************************************/
XMC_CCU4_SLICE_EVENT_CONFIG_t ENCODER_POSIF_0_position_capture_eventconfig =
{
  .mapped_input = XMC_CCU4_SLICE_INPUT_AP, 
  .edge         = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_FALLING_EDGE,          
  .level        = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,         
  .duration     = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED      
};
XMC_CCU4_SLICE_EVENT_CONFIG_t ENCODER_POSIF_0_position_counting_eventconfig =
{
  .mapped_input = XMC_CCU4_SLICE_INPUT_AE, 
  .edge         = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE,          
  .level        = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,         
  .duration     = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED      
};
XMC_CCU4_SLICE_EVENT_CONFIG_t ENCODER_POSIF_0_position_count_dir_eventconfig =
{
  .mapped_input = XMC_CCU4_SLICE_INPUT_AF, 
  .edge         = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE,          
  .level        = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW,         
  .duration     = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED      
};

XMC_CCU4_SLICE_EVENT_CONFIG_t ENCODER_POSIF_0_time_bw_ticks_capture_eventconfig =
{
  .mapped_input = XMC_CCU4_SLICE_INPUT_AF, 
  .edge         = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE,          
  .level        = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,         
  .duration     = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED      
};

XMC_CCU4_SLICE_EVENT_CONFIG_t ENCODER_POSIF_0_time_triggerpoint_capture_eventconfig =
{
  .mapped_input = XMC_CCU4_SLICE_INPUT_AP, 
  .edge         = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_FALLING_EDGE,          
  .level        = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,         
  .duration     = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED      
};
XMC_CCU4_SLICE_EVENT_CONFIG_t ENCODER_POSIF_0_triggergen_start_eventconfig =
{
  .mapped_input = XMC_CCU4_SLICE_INPUT_AF, 
  .edge         = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE,          
  .level        = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,         
  .duration     = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED      
};
/**************************************************************************************************************/
/*************************************CC4 Compare/Capture Init Configuration***********************************/
/**************************************************************************************************************/
/* Configure the ccu4 timer structure use for phase delay */
XMC_CCU4_SLICE_COMPARE_CONFIG_t ENCODER_POSIF_0_trigger_slice_timer_init =
{
  .timer_mode          = XMC_CCU4_SLICE_TIMER_COUNT_MODE_EA,        
  .monoshot            = 0U,      
  .shadow_xfer_clear   = 1U,  
  .dither_timer_period = 0U,   
  .dither_duty_cycle   = 0U, 
  .prescaler_mode      = (uint32_t)XMC_CCU4_SLICE_PRESCALER_MODE_NORMAL,  
  .mcm_enable          = 0U,
  .prescaler_initval   = 1U,
  .float_limit         = 0U,          
  .dither_limit        = 0U,          
  .passive_level       = (uint32_t)XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_LOW,    
  .timer_concatenation = 0U
};
XMC_CCU4_SLICE_CAPTURE_CONFIG_t ENCODER_POSIF_0_position_capture_init =
{
  .timer_clear_mode    = (uint32_t)XMC_CCU4_SLICE_TIMER_CLEAR_MODE_NEVER,
  .same_event          = 0U,       
  .fifo_enable         = 0U,     
  .prescaler_mode      = 0U,
  .ignore_full_flag    = 0U,
};

XMC_CCU4_SLICE_CAPTURE_CONFIG_t ENCODER_POSIF_0_time_bw_ticks_capture_init =
{
  .timer_clear_mode    = (uint32_t)XMC_CCU4_SLICE_TIMER_CLEAR_MODE_CAP_LOW,
  .same_event          = 0U,       
  .fifo_enable         = 0U,     
  .prescaler_mode      = 0U,
  .ignore_full_flag    = 1U,
  .prescaler_initval   = 5U
};

ENCODER_POSIF_CCU4_SLICE_t ENCODER_POSIF_0_position_counter=
{
  .slice_ptr           = (CCU4_CC4_TypeDef*)(void*)CCU41_CC41,  
  .module_ptr          = (CCU4_GLOBAL_TypeDef*)(void*) CCU41_BASE,  
  .shadow_transfer_msk = (uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_1,
  .slice_number        = (uint8_t)1 
}; 

ENCODER_POSIF_CCU4_SLICE_t ENCODER_POSIF_0_time_bw_ticks_counter =
{
  .slice_ptr           = (CCU4_CC4_TypeDef*)(void*)CCU41_CC42,  
  .module_ptr          = (CCU4_GLOBAL_TypeDef*)(void*) CCU41_BASE, 
  .shadow_transfer_msk = (uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_2,  
  .slice_number        = (uint8_t)2
}; 

ENCODER_POSIF_CCU4_SLICE_t ENCODER_POSIF_0_trigger_generator =
{
  .slice_ptr           = (CCU4_CC4_TypeDef*)(void*)CCU41_CC43,  
  .module_ptr          = (CCU4_GLOBAL_TypeDef*)(void*) CCU41_BASE, 
  .shadow_transfer_msk = (uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_3,  
  .slice_number        = (uint8_t)3
}; 
/***************************************Posif Quadrature init configuration*********************************/ 
XMC_POSIF_QD_CONFIG_t ENCODER_POSIF_0_InitHandle =
{
  .mode                = (XMC_POSIF_QD_MODE_t)0,
  .phase_a             = 1U,
  .phase_b             = 1U,
  .phase_leader        = 1U,
  .index               = 1U
};
/**************************************************************************************************************/
/*******************************************Posif general configuration***********************************************/
/**************************************************************************************************************/
XMC_POSIF_CONFIG_t ENCODER_POSIF_0_PosifConf =
{
  .mode   = XMC_POSIF_MODE_QD,    /**< POSIF Operational mode */
  .input0 = XMC_POSIF_INPUT_PORT_B,    /**< Choice of input for Input-1 */
  .input1 = XMC_POSIF_INPUT_PORT_B,    /**< Choice of input for Input-2 */
  .input2 = XMC_POSIF_INPUT_PORT_B,   /**< Choice of input for Input-3 */
  .filter = XMC_POSIF_FILTER_DISABLED,       /**< Input filter configuration */
};
/**************************************************************************************************************/
/*******************************************APP Config Structure***********************************************/
/**************************************************************************************************************/
ENCODER_POSIF_Config_t ENCODER_POSIF_0_Config =
{
  .encoder_pin          = (ENCODER_POSIF_ENABLE_PINLEVEL_t)ENCODER_POSIF_EPIN_LOW, 
  .extrapolation_type   = ENCODER_POSIF_1ST_ORDER_EXTRAPOLATION,
  .timestamp_slice_pm_sr= (XMC_CCU4_SLICE_SR_ID_t)0,
  .encoder_type         = ENCODER_POSIF_ENCODER_WITH_INDEX_SIGNAL,
  .angle_scale          = 4,
  .speed_const          = 899945,
  .module_frequency     = 3000000U,
  .time_offset_scale    = 3000U,
  .max_toffset          = 1000000U,
  .ticks_per_revolution = 16383U,

  .timestamp_period     = 238U,
  .posif_qd_sr          = {
                            (uint8_t)XMC_POSIF_SR_ID_0,
                            (uint8_t)XMC_POSIF_SR_ID_0,
                            (uint8_t)XMC_POSIF_SR_ID_0,
                            (uint8_t)XMC_POSIF_SR_ID_0,
                            (uint8_t)XMC_POSIF_SR_ID_0
                          },
  .enable_eru           = {
                            0U,
                            0U,
                            0U
                          },

  .enable_anglecalc_isr  = 0U, 
  .enable_rev_counter    = 0U,
  .enable_index_evt      = 0U,
  .enable_phaseerr_evt   = 0U,
  .enable_dirchange_evt  = 0U,
  .enable_qclk_evt       = 0U,
  .enable_pclk_evt       = 0U
};
ENCODER_POSIF_t ENCODER_POSIF_0 =
{

  .encoder_enable_input_ptr     = &ENCODER_POSIF_0_Enable_Encoder_PadResource,

  .encoder_input_ptr            = {
                                    &ENCODER_POSIF_0_Phase_A_PadResource,
                                    &ENCODER_POSIF_0_Phase_B_PadResource,

                                    &ENCODER_POSIF_0_Index_PadResource,

                                  },
  #if (ENCODER_POSIF_ERU_AVAILABLE == 1U)
  .etl_conf_ptr                 = {
                                   NULL,
                                   NULL,
                                   NULL
                                  },
  .etl_resource_ptr             = {
                                   NULL,
                                   NULL,
                                   NULL
                                  },
  .ogu_conf_ptr                 = {
                                   NULL,
                                   NULL,
                                   NULL
                                  },
  #endif  
  .position_counter_init_ptr    = &ENCODER_POSIF_0_position_capture_init,      

  .revolution_counter_init_ptr  = NULL,
  .revolution_counter_ptr       = NULL,
  .rev_counterevent_ptr         = NULL,
  .rev_countdir_event_ptr       = NULL,
  .rev_captureevent_ptr         = NULL,

  .time_bw_ticks_init_ptr       = &ENCODER_POSIF_0_time_bw_ticks_capture_init,
  .trigger_slice_init_ptr       = &ENCODER_POSIF_0_trigger_slice_timer_init, 
  .position_counter_ptr         = &ENCODER_POSIF_0_position_counter,  

  .time_bw_ticks_ptr            = &ENCODER_POSIF_0_time_bw_ticks_counter,
  .timestamp_trigger_slice_ptr  = &ENCODER_POSIF_0_trigger_generator,
  .global_ptr                   = (POSIF_GLOBAL_TypeDef*)(void*)POSIF1,
  .config_ptr                   = &ENCODER_POSIF_0_Config,
  .posif_qd_ptr                 = &ENCODER_POSIF_0_InitHandle,
  .posifconfig_ptr              = &ENCODER_POSIF_0_PosifConf,
  .timestamp_trigger_start_ptr  = &ENCODER_POSIF_0_triggergen_start_eventconfig,
  .pos_captureevent_ptr         = &ENCODER_POSIF_0_position_capture_eventconfig,
  .tbt_captureevent_ptr         = &ENCODER_POSIF_0_time_bw_ticks_capture_eventconfig,
  .tbtp_captureevent_ptr        = &ENCODER_POSIF_0_time_triggerpoint_capture_eventconfig,
  .pos_counterevent_ptr         = &ENCODER_POSIF_0_position_counting_eventconfig,
  .pos_countdir_event_ptr       = &ENCODER_POSIF_0_position_count_dir_eventconfig,
  .encoder_pinconfig_ptr        = &ENCODER_POSIF_0_Encoder_PadConfig,

  .enable_enc_pin_cfg_ptr       = &ENCODER_POSIF_0_En_Encoderpin_Config,

  .global_posif_handle_ptr      = &GLOBAL_POSIF_0,
  .global_ccu4_handle_ptr       = &GLOBAL_CCU4_0,

  .speed_pt1_filter             = &ENCODER_POSIF_0_Speed_PT1Filter,
  .state                        = ENCODER_POSIF_UNINITIALISED,
};

